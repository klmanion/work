+============+
|  Foreword  |
+============+

A program is like philosophy in that they transpire after that which they are.
This is not imitation.  A program _expresses_ a _comprehension_ of some matter.
As an answer to its problem the program necessarily presupposes some
understanding of what sort of matter it is meant to deal with.  To develop the
program (beyond the mere mapping of the programmer's internal notion into code)
is to develop the understanding of its problem.---The understanding's passage
into its succeeding understanding (through negation) alters the sort of answer
that it is to its problem.  As an answer, the program presupposes a mindset, or
understanding, which the user is obliged to adopt in their use of it.  This is
necessarily a restriction on the user and the possible ways they can think
_with_ the program.  If the program is an answer then it is only that answer,
that way of answering, the problem, and the user is forced into the program's
understanding, answering in the same way with some of the work exported to the
computer.
	To move beyond any one understanding of its problem is to place the
onus of developing an understanding onto the user.  This is done by negating
the notion of program as answer, which leads us to the notion of program as
problem.  The program itself becomes a problem for the user.  This allows the
user to develop their own understanding and supply their own answer, i.e. their
own way of using the program.  But the answer is not an answer to the problem
the program was designed to solve, rather is it an answer to the problem which
the program is itself.  Therefore, we must develop the relation of the program
as problem to the problem of the program.  Priorly, the program was related to
its problem as an answer, which is to say it instantiated the problematic in
some specific way which was resolvable somehow.  This kind of program is
designed to produce solutions with its answer.  But this precludes the
possibility of the user contemplating the problem as such.  They are no longer
the one answering, only inputting.  Now, the program is related as another
problem.  This problem is, at first, the problem of how to use the program,
which is, secondly, the development of an understanding of the program's
problem, and, thirdly, that problematic itself.  The program, then, acquaints
the user with its problem.  Different ways of using the program are different
ways of dealing with the problem, i.e. different formulations of it.  But it is
only this, the pure formulation of the problem.
	As formulation the program provides different ways of thinking about
the problematic at hand, it is the form given to the matter which constitutes
the problem.  This subject matter is the content of the formulation, which
relates to it as form.  The formulations are then different ways of thinking
about the matter which the program concerns itself with.  The content is the
reality of the forms which it appears in, and is not thereby exhausted.  The
content is indifferent to its form, yet is always formed in some way.  This is
to say that the way in which it is expressed is merely a reflection of itself.
That is to say, though, that in reflecting itself differently it reveals
itself to the mind through different apertures.  And through these we know more
about the problematic, by viewing it from different sides and positing it
in different ways.  And now we begin to conjecture at answers to the problem by
means of this knowlege.  This really means giving extension to the problem:
finding what sort of answers there are.  But it is not answers we are after;
neither are we after solutions.  The comprehension of the problematic demands
that the problem exist as problem, since solutions to it are only shifting
surface-level determinacies.  The kind of program we are talking about now is a
vehicle.  It is through the program that the mind navigates the problematic.

